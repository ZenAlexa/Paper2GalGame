/**\n * Multimodal AI Engine - Advanced Formula Recognition\n *\n * Integrates with OpenRouter API for Gemini 3.0 and other multimodal models\n * to provide state-of-the-art formula recognition and semantic understanding.\n */\n\nimport { OpenRouterClient } from '../../../script-generator/src/openrouter/client';\nimport { createHash } from 'crypto';\nimport { promises as fs } from 'fs';\nimport type {\n  EnhancedEquation,\n  EnhancedFigure,\n  EnhancedParserConfig,\n  ProgressCallback,\n  ParsingProgress\n} from '../../types/enhanced-paper';\nimport type {\n  ChatCompletionRequest,\n  OpenRouterConfig\n} from '../../../script-generator/src/types';\n\n/**\n * Formula analysis request\n */\ninterface FormulaAnalysisRequest {\n  /** Base64 encoded image of the formula */\n  imageData: string;\n  \n  /** Bounding box coordinates */\n  bbox: [number, number, number, number];\n  \n  /** Context text around the formula */\n  context: string;\n  \n  /** Expected complexity level */\n  expectedComplexity?: 'simple' | 'medium' | 'complex';\n}\n\n/**\n * Formula analysis response from AI\n */\ninterface FormulaAnalysisResponse {\n  /** LaTeX representation */\n  latex: string;\n  \n  /** Semantic description */\n  description: string;\n  \n  /** Mathematical concepts involved */\n  concepts: string[];\n  \n  /** Confidence score (0-1) */\n  confidence: number;\n  \n  /** Alternative representations */\n  alternatives?: string[];\n  \n  /** Educational explanation */\n  explanation?: string;\n  \n  /** Complexity assessment */\n  complexity: 'simple' | 'medium' | 'complex';\n  \n  /** Math type classification */\n  mathType: 'arithmetic' | 'algebra' | 'calculus' | 'statistics' | 'geometry' | 'logic' | 'other';\n}\n\n/**\n * Configuration for multimodal engine\n */\nexport interface MultimodalEngineConfig {\n  /** OpenRouter configuration */\n  openRouter: OpenRouterConfig;\n  \n  /** Preferred vision model */\n  visionModel: string;\n  \n  /** Fallback models */\n  fallbackModels: string[];\n  \n  /** Maximum concurrent API calls */\n  maxConcurrency: number;\n  \n  /** Cost control settings */\n  costControl: {\n    maxCostPerPaper: number;\n    maxFormulasPerPaper: number;\n    enableCaching: boolean;\n  };\n  \n  /** Quality thresholds */\n  qualityThresholds: {\n    minConfidence: number;\n    retryLowConfidence: boolean;\n  };\n}\n\n/**\n * Cache entry for formula recognition\n */\ninterface FormulaCacheEntry {\n  hash: string;\n  result: FormulaAnalysisResponse;\n  timestamp: Date;\n  model: string;\n}\n\n/**\n * Multimodal AI engine for advanced formula recognition\n */\nexport class MultimodalEngine {\n  private client: OpenRouterClient;\n  private config: MultimodalEngineConfig;\n  private progressCallback?: ProgressCallback;\n  private cache: Map<string, FormulaCacheEntry> = new Map();\n  private apiCallCount = 0;\n  private totalCost = 0;\n\n  constructor(config: MultimodalEngineConfig) {\n    this.config = config;\n    this.client = new OpenRouterClient(config.openRouter);\n  }\n\n  /**\n   * Set progress callback for long-running operations\n   */\n  setProgressCallback(callback: ProgressCallback): void {\n    this.progressCallback = callback;\n  }\n\n  /**\n   * Enhanced formula recognition using multimodal AI\n   */\n  async enhanceFormulas(\n    formulaRequests: FormulaAnalysisRequest[]\n  ): Promise<EnhancedEquation[]> {\n    this.reportProgress({\n      stage: 'ai-enhancement',\n      progress: 0,\n      description: 'Starting AI-powered formula analysis'\n    });\n\n    const enhancedFormulas: EnhancedEquation[] = [];\n    const maxFormulas = Math.min(\n      formulaRequests.length,\n      this.config.costControl.maxFormulasPerPaper\n    );\n\n    // Process formulas in batches to respect concurrency limits\n    const batchSize = this.config.maxConcurrency;\n    \n    for (let i = 0; i < maxFormulas; i += batchSize) {\n      const batch = formulaRequests.slice(i, i + batchSize);\n      const batchPromises = batch.map(request => this.analyzeFormula(request));\n      \n      try {\n        const batchResults = await Promise.allSettled(batchPromises);\n        \n        batchResults.forEach((result, batchIndex) => {\n          const globalIndex = i + batchIndex;\n          \n          if (result.status === 'fulfilled') {\n            enhancedFormulas.push(this.createEnhancedEquation(\n              result.value,\n              formulaRequests[globalIndex],\n              globalIndex\n            ));\n          } else {\n            console.warn(`Formula analysis failed for index ${globalIndex}:`, result.reason);\n            \n            // Create fallback enhanced equation\n            enhancedFormulas.push(this.createFallbackEquation(\n              formulaRequests[globalIndex],\n              globalIndex\n            ));\n          }\n        });\n        \n        // Report progress\n        const progressPercent = ((i + batch.length) / maxFormulas) * 100;\n        this.reportProgress({\n          stage: 'ai-enhancement',\n          progress: progressPercent,\n          description: `Processed ${i + batch.length} of ${maxFormulas} formulas`,\n          itemsProcessed: {\n            current: i + batch.length,\n            total: maxFormulas,\n            type: 'formulas'\n          }\n        });\n        \n        // Check cost limit\n        if (this.totalCost > this.config.costControl.maxCostPerPaper) {\n          console.warn('Cost limit exceeded, stopping AI processing');\n          break;\n        }\n        \n      } catch (error) {\n        console.error('Batch processing failed:', error);\n        \n        // Create fallback equations for the entire batch\n        batch.forEach((request, batchIndex) => {\n          const globalIndex = i + batchIndex;\n          enhancedFormulas.push(this.createFallbackEquation(request, globalIndex));\n        });\n      }\n    }\n\n    return enhancedFormulas;\n  }\n\n  /**\n   * Analyze individual formula using AI\n   */\n  private async analyzeFormula(\n    request: FormulaAnalysisRequest\n  ): Promise<FormulaAnalysisResponse> {\n    // Check cache first\n    if (this.config.costControl.enableCaching) {\n      const cacheKey = this.generateCacheKey(request);\n      const cached = this.cache.get(cacheKey);\n      \n      if (cached && this.isCacheValid(cached)) {\n        return cached.result;\n      }\n    }\n\n    // Prepare the AI request\n    const systemPrompt = this.buildSystemPrompt();\n    const userPrompt = this.buildUserPrompt(request);\n    \n    const chatRequest: ChatCompletionRequest = {\n      model: this.config.visionModel,\n      messages: [\n        { role: 'system', content: systemPrompt },\n        {\n          role: 'user',\n          content: [\n            { type: 'text', text: userPrompt },\n            {\n              type: 'image_url',\n              image_url: {\n                url: `data:image/png;base64,${request.imageData}`\n              }\n            }\n          ]\n        }\n      ],\n      temperature: 0.1, // Low temperature for consistency\n      max_tokens: 1000,\n      reasoning: true // Enable reasoning for better quality\n    };\n\n    try {\n      const startTime = Date.now();\n      const response = await this.client.chatCompletion(chatRequest);\n      const processingTime = Date.now() - startTime;\n      \n      this.apiCallCount++;\n      this.estimateCost();\n      \n      const analysis = this.parseAnalysisResponse(response.choices[0].message.content || '');\n      \n      // Cache the result\n      if (this.config.costControl.enableCaching) {\n        const cacheKey = this.generateCacheKey(request);\n        this.cache.set(cacheKey, {\n          hash: cacheKey,\n          result: analysis,\n          timestamp: new Date(),\n          model: this.config.visionModel\n        });\n      }\n      \n      return analysis;\n      \n    } catch (error) {\n      // Try fallback models\n      for (const fallbackModel of this.config.fallbackModels) {\n        try {\n          const fallbackRequest = { ...chatRequest, model: fallbackModel };\n          const response = await this.client.chatCompletion(fallbackRequest);\n          \n          this.apiCallCount++;\n          this.estimateCost();\n          \n          return this.parseAnalysisResponse(response.choices[0].message.content || '');\n          \n        } catch (fallbackError) {\n          console.warn(`Fallback model ${fallbackModel} also failed:`, fallbackError);\n          continue;\n        }\n      }\n      \n      throw new Error(`All models failed for formula analysis: ${error}`);\n    }\n  }\n\n  /**\n   * Build system prompt for formula analysis\n   */\n  private buildSystemPrompt(): string {\n    return `# Mathematical Formula Analysis Expert\n\nYou are an expert in mathematical formula recognition and analysis. Your task is to:\n\n1. **Extract LaTeX**: Provide accurate LaTeX representation of the mathematical formula\n2. **Semantic Understanding**: Explain what the formula represents mathematically\n3. **Educational Context**: Provide learning-friendly explanations suitable for a visual novel\n4. **Quality Assessment**: Evaluate complexity and mathematical type\n\n## Output Format\n\nRespond with a JSON object containing:\n\\`\\`\\`json\n{\n  \"latex\": \"LaTeX representation\",\n  \"description\": \"What this formula represents\",\n  \"concepts\": [\"list\", \"of\", \"mathematical\", \"concepts\"],\n  \"confidence\": 0.95,\n  \"complexity\": \"simple|medium|complex\",\n  \"mathType\": \"arithmetic|algebra|calculus|statistics|geometry|logic|other\",\n  \"explanation\": \"Educational explanation suitable for learning\",\n  \"alternatives\": [\"alternative\", \"representations\"]\n}\n\\`\\`\\`\n\n## Quality Guidelines\n\n- Ensure LaTeX is syntactically correct\n- Focus on educational value for visual novel context\n- Consider the formula's role in academic learning\n- Provide clear, jargon-free explanations\n- Assess complexity appropriately for learning progression`;\n  }\n\n  /**\n   * Build user prompt for specific formula\n   */\n  private buildUserPrompt(request: FormulaAnalysisRequest): string {\n    return `Please analyze this mathematical formula image.\n\n**Context**: ${request.context || 'No context provided'}\n\n**Expected Complexity**: ${request.expectedComplexity || 'unknown'}\n\nPlease provide accurate LaTeX representation and educational analysis suitable for a visual novel learning experience. Focus on making complex mathematical concepts approachable for learners.`;\n  }\n\n  /**\n   * Parse AI response into structured analysis\n   */\n  private parseAnalysisResponse(content: string): FormulaAnalysisResponse {\n    try {\n      // Try to extract JSON from response\n      const jsonMatch = content.match(/```json\\s*([\\s\\S]*?)\\s*```/) || \n                        content.match(/```\\s*([\\s\\S]*?)\\s*```/) ||\n                        [null, content];\n      \n      if (jsonMatch && jsonMatch[1]) {\n        const parsed = JSON.parse(jsonMatch[1]);\n        \n        return {\n          latex: parsed.latex || '',\n          description: parsed.description || '',\n          concepts: Array.isArray(parsed.concepts) ? parsed.concepts : [],\n          confidence: Math.max(0, Math.min(1, parsed.confidence || 0.8)),\n          complexity: ['simple', 'medium', 'complex'].includes(parsed.complexity) \n            ? parsed.complexity : 'medium',\n          mathType: ['arithmetic', 'algebra', 'calculus', 'statistics', 'geometry', 'logic', 'other']\n            .includes(parsed.mathType) ? parsed.mathType : 'other',\n          explanation: parsed.explanation || '',\n          alternatives: Array.isArray(parsed.alternatives) ? parsed.alternatives : []\n        };\n      }\n    } catch (error) {\n      console.warn('Failed to parse AI response as JSON:', error);\n    }\n    \n    // Fallback to text parsing\n    return {\n      latex: this.extractLatexFromText(content),\n      description: content.substring(0, 200),\n      concepts: [],\n      confidence: 0.6,\n      complexity: 'medium',\n      mathType: 'other',\n      explanation: content\n    };\n  }\n\n  /**\n   * Extract LaTeX from plain text response\n   */\n  private extractLatexFromText(text: string): string {\n    // Look for LaTeX patterns in text\n    const latexPatterns = [\n      /\\$\\$([^$]+)\\$\\$/g,  // $$...$$\n      /\\$([^$]+)\\$/g,     // $...$\n      /\\\\\\[([^\\]]+)\\\\\\]/g, // \\[...\\]\n      /\\\\\\(([^\\)]+)\\\\\\)/g  // \\(...\\)\n    ];\n    \n    for (const pattern of latexPatterns) {\n      const match = text.match(pattern);\n      if (match && match[1]) {\n        return match[1].trim();\n      }\n    }\n    \n    // If no LaTeX found, return cleaned text\n    return text.replace(/[^\\w\\s\\+\\-\\*\\/\\(\\)\\=]/g, '').trim().substring(0, 100);\n  }\n\n  /**\n   * Create enhanced equation from AI analysis\n   */\n  private createEnhancedEquation(\n    analysis: FormulaAnalysisResponse,\n    request: FormulaAnalysisRequest,\n    index: number\n  ): EnhancedEquation {\n    return {\n      id: `ai-formula-${index}`,\n      latex: analysis.latex,\n      text: analysis.description,\n      position: index,\n      inline: this.isInlineFromBbox(request.bbox),\n      bbox: request.bbox,\n      confidence: analysis.confidence,\n      semanticDescription: analysis.description,\n      context: request.context,\n      complexity: analysis.complexity,\n      mathType: analysis.mathType,\n      visualImage: request.imageData,\n      \n      aiMetadata: {\n        model: this.config.visionModel,\n        processingTime: 0, // Will be updated\n        alternatives: analysis.alternatives,\n        method: 'visual',\n        quality: {\n          latexAccuracy: analysis.confidence,\n          semanticRelevance: analysis.confidence * 0.9,\n          contextAlignment: request.context ? 0.8 : 0.6\n        }\n      },\n      \n      educational: {\n        difficulty: this.mapComplexityToDifficulty(analysis.complexity),\n        concepts: analysis.concepts,\n        explanation: analysis.explanation\n      }\n    };\n  }\n\n  /**\n   * Create fallback equation when AI fails\n   */\n  private createFallbackEquation(\n    request: FormulaAnalysisRequest,\n    index: number\n  ): EnhancedEquation {\n    return {\n      id: `fallback-formula-${index}`,\n      latex: 'Formula recognition failed',\n      text: 'Mathematical formula (recognition failed)',\n      position: index,\n      inline: this.isInlineFromBbox(request.bbox),\n      bbox: request.bbox,\n      confidence: 0.3,\n      complexity: 'medium',\n      mathType: 'other',\n      visualImage: request.imageData\n    };\n  }\n\n  /**\n   * Helper methods\n   */\n  private isInlineFromBbox(bbox: [number, number, number, number]): boolean {\n    const height = bbox[3] - bbox[1];\n    return height < 0.05; // Less than 5% of page height\n  }\n\n  private mapComplexityToDifficulty(\n    complexity: 'simple' | 'medium' | 'complex'\n  ): 'beginner' | 'intermediate' | 'advanced' {\n    const mapping = {\n      simple: 'beginner' as const,\n      medium: 'intermediate' as const,\n      complex: 'advanced' as const\n    };\n    return mapping[complexity];\n  }\n\n  private generateCacheKey(request: FormulaAnalysisRequest): string {\n    const data = {\n      image: request.imageData.substring(0, 100), // Hash portion\n      bbox: request.bbox,\n      context: request.context?.substring(0, 100)\n    };\n    return createHash('sha256').update(JSON.stringify(data)).digest('hex');\n  }\n\n  private isCacheValid(entry: FormulaCacheEntry): boolean {\n    const age = Date.now() - entry.timestamp.getTime();\n    return age < 24 * 60 * 60 * 1000; // 24 hours\n  }\n\n  private estimateCost(): void {\n    // Rough estimation: $0.01 per API call for vision models\n    this.totalCost += 0.01;\n  }\n\n  private reportProgress(progress: ParsingProgress): void {\n    if (this.progressCallback) {\n      this.progressCallback(progress);\n    }\n  }\n\n  /**\n   * Get processing statistics\n   */\n  getStats(): {\n    apiCalls: number;\n    totalCost: number;\n    cacheHits: number;\n    cacheMisses: number;\n  } {\n    return {\n      apiCalls: this.apiCallCount,\n      totalCost: this.totalCost,\n      cacheHits: 0, // TODO: implement cache hit tracking\n      cacheMisses: 0 // TODO: implement cache miss tracking\n    };\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Test connection to OpenRouter API\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      return await this.client.testConnection();\n    } catch {\n      return false;\n    }\n  }\n}\n"